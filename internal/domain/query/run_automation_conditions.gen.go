// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"automation-engine/internal/domain/model"
)

func newRunAutomationCondition(db *gorm.DB, opts ...gen.DOOption) runAutomationCondition {
	_runAutomationCondition := runAutomationCondition{}

	_runAutomationCondition.runAutomationConditionDo.UseDB(db, opts...)
	_runAutomationCondition.runAutomationConditionDo.UseModel(&model.RunAutomationCondition{})

	tableName := _runAutomationCondition.runAutomationConditionDo.TableName()
	_runAutomationCondition.ALL = field.NewAsterisk(tableName)
	_runAutomationCondition.AutomationConditionID = field.NewString(tableName, "automation_condition_id")
	_runAutomationCondition.AutomationID = field.NewString(tableName, "automation_id")
	_runAutomationCondition.ConditionID = field.NewString(tableName, "condition_id")
	_runAutomationCondition.OperatorID = field.NewString(tableName, "operator_id")
	_runAutomationCondition.Value = field.NewString(tableName, "value")
	_runAutomationCondition.UnitID = field.NewString(tableName, "unit_id")
	_runAutomationCondition.Created = field.NewTime(tableName, "created")
	_runAutomationCondition.CreatedBy = field.NewString(tableName, "created_by")
	_runAutomationCondition.LastUpd = field.NewTime(tableName, "last_upd")
	_runAutomationCondition.LastUpdBy = field.NewString(tableName, "last_upd_by")

	_runAutomationCondition.fillFieldMap()

	return _runAutomationCondition
}

type runAutomationCondition struct {
	runAutomationConditionDo runAutomationConditionDo

	ALL                   field.Asterisk
	AutomationConditionID field.String
	AutomationID          field.String
	ConditionID           field.String
	OperatorID            field.String
	Value                 field.String
	UnitID                field.String
	Created               field.Time
	CreatedBy             field.String
	LastUpd               field.Time
	LastUpdBy             field.String

	fieldMap map[string]field.Expr
}

func (r runAutomationCondition) Table(newTableName string) *runAutomationCondition {
	r.runAutomationConditionDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r runAutomationCondition) As(alias string) *runAutomationCondition {
	r.runAutomationConditionDo.DO = *(r.runAutomationConditionDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *runAutomationCondition) updateTableName(table string) *runAutomationCondition {
	r.ALL = field.NewAsterisk(table)
	r.AutomationConditionID = field.NewString(table, "automation_condition_id")
	r.AutomationID = field.NewString(table, "automation_id")
	r.ConditionID = field.NewString(table, "condition_id")
	r.OperatorID = field.NewString(table, "operator_id")
	r.Value = field.NewString(table, "value")
	r.UnitID = field.NewString(table, "unit_id")
	r.Created = field.NewTime(table, "created")
	r.CreatedBy = field.NewString(table, "created_by")
	r.LastUpd = field.NewTime(table, "last_upd")
	r.LastUpdBy = field.NewString(table, "last_upd_by")

	r.fillFieldMap()

	return r
}

func (r *runAutomationCondition) WithContext(ctx context.Context) IRunAutomationConditionDo {
	return r.runAutomationConditionDo.WithContext(ctx)
}

func (r runAutomationCondition) TableName() string { return r.runAutomationConditionDo.TableName() }

func (r runAutomationCondition) Alias() string { return r.runAutomationConditionDo.Alias() }

func (r runAutomationCondition) Columns(cols ...field.Expr) gen.Columns {
	return r.runAutomationConditionDo.Columns(cols...)
}

func (r *runAutomationCondition) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *runAutomationCondition) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 10)
	r.fieldMap["automation_condition_id"] = r.AutomationConditionID
	r.fieldMap["automation_id"] = r.AutomationID
	r.fieldMap["condition_id"] = r.ConditionID
	r.fieldMap["operator_id"] = r.OperatorID
	r.fieldMap["value"] = r.Value
	r.fieldMap["unit_id"] = r.UnitID
	r.fieldMap["created"] = r.Created
	r.fieldMap["created_by"] = r.CreatedBy
	r.fieldMap["last_upd"] = r.LastUpd
	r.fieldMap["last_upd_by"] = r.LastUpdBy
}

func (r runAutomationCondition) clone(db *gorm.DB) runAutomationCondition {
	r.runAutomationConditionDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r runAutomationCondition) replaceDB(db *gorm.DB) runAutomationCondition {
	r.runAutomationConditionDo.ReplaceDB(db)
	return r
}

type runAutomationConditionDo struct{ gen.DO }

type IRunAutomationConditionDo interface {
	gen.SubQuery
	Debug() IRunAutomationConditionDo
	WithContext(ctx context.Context) IRunAutomationConditionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRunAutomationConditionDo
	WriteDB() IRunAutomationConditionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRunAutomationConditionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRunAutomationConditionDo
	Not(conds ...gen.Condition) IRunAutomationConditionDo
	Or(conds ...gen.Condition) IRunAutomationConditionDo
	Select(conds ...field.Expr) IRunAutomationConditionDo
	Where(conds ...gen.Condition) IRunAutomationConditionDo
	Order(conds ...field.Expr) IRunAutomationConditionDo
	Distinct(cols ...field.Expr) IRunAutomationConditionDo
	Omit(cols ...field.Expr) IRunAutomationConditionDo
	Join(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo
	Group(cols ...field.Expr) IRunAutomationConditionDo
	Having(conds ...gen.Condition) IRunAutomationConditionDo
	Limit(limit int) IRunAutomationConditionDo
	Offset(offset int) IRunAutomationConditionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRunAutomationConditionDo
	Unscoped() IRunAutomationConditionDo
	Create(values ...*model.RunAutomationCondition) error
	CreateInBatches(values []*model.RunAutomationCondition, batchSize int) error
	Save(values ...*model.RunAutomationCondition) error
	First() (*model.RunAutomationCondition, error)
	Take() (*model.RunAutomationCondition, error)
	Last() (*model.RunAutomationCondition, error)
	Find() ([]*model.RunAutomationCondition, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RunAutomationCondition, err error)
	FindInBatches(result *[]*model.RunAutomationCondition, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.RunAutomationCondition) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRunAutomationConditionDo
	Assign(attrs ...field.AssignExpr) IRunAutomationConditionDo
	Joins(fields ...field.RelationField) IRunAutomationConditionDo
	Preload(fields ...field.RelationField) IRunAutomationConditionDo
	FirstOrInit() (*model.RunAutomationCondition, error)
	FirstOrCreate() (*model.RunAutomationCondition, error)
	FindByPage(offset int, limit int) (result []*model.RunAutomationCondition, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRunAutomationConditionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r runAutomationConditionDo) Debug() IRunAutomationConditionDo {
	return r.withDO(r.DO.Debug())
}

func (r runAutomationConditionDo) WithContext(ctx context.Context) IRunAutomationConditionDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r runAutomationConditionDo) ReadDB() IRunAutomationConditionDo {
	return r.Clauses(dbresolver.Read)
}

func (r runAutomationConditionDo) WriteDB() IRunAutomationConditionDo {
	return r.Clauses(dbresolver.Write)
}

func (r runAutomationConditionDo) Session(config *gorm.Session) IRunAutomationConditionDo {
	return r.withDO(r.DO.Session(config))
}

func (r runAutomationConditionDo) Clauses(conds ...clause.Expression) IRunAutomationConditionDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r runAutomationConditionDo) Returning(value interface{}, columns ...string) IRunAutomationConditionDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r runAutomationConditionDo) Not(conds ...gen.Condition) IRunAutomationConditionDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r runAutomationConditionDo) Or(conds ...gen.Condition) IRunAutomationConditionDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r runAutomationConditionDo) Select(conds ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r runAutomationConditionDo) Where(conds ...gen.Condition) IRunAutomationConditionDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r runAutomationConditionDo) Order(conds ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r runAutomationConditionDo) Distinct(cols ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r runAutomationConditionDo) Omit(cols ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r runAutomationConditionDo) Join(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r runAutomationConditionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r runAutomationConditionDo) RightJoin(table schema.Tabler, on ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r runAutomationConditionDo) Group(cols ...field.Expr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r runAutomationConditionDo) Having(conds ...gen.Condition) IRunAutomationConditionDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r runAutomationConditionDo) Limit(limit int) IRunAutomationConditionDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r runAutomationConditionDo) Offset(offset int) IRunAutomationConditionDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r runAutomationConditionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRunAutomationConditionDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r runAutomationConditionDo) Unscoped() IRunAutomationConditionDo {
	return r.withDO(r.DO.Unscoped())
}

func (r runAutomationConditionDo) Create(values ...*model.RunAutomationCondition) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r runAutomationConditionDo) CreateInBatches(values []*model.RunAutomationCondition, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r runAutomationConditionDo) Save(values ...*model.RunAutomationCondition) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r runAutomationConditionDo) First() (*model.RunAutomationCondition, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.RunAutomationCondition), nil
	}
}

func (r runAutomationConditionDo) Take() (*model.RunAutomationCondition, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.RunAutomationCondition), nil
	}
}

func (r runAutomationConditionDo) Last() (*model.RunAutomationCondition, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.RunAutomationCondition), nil
	}
}

func (r runAutomationConditionDo) Find() ([]*model.RunAutomationCondition, error) {
	result, err := r.DO.Find()
	return result.([]*model.RunAutomationCondition), err
}

func (r runAutomationConditionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RunAutomationCondition, err error) {
	buf := make([]*model.RunAutomationCondition, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r runAutomationConditionDo) FindInBatches(result *[]*model.RunAutomationCondition, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r runAutomationConditionDo) Attrs(attrs ...field.AssignExpr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r runAutomationConditionDo) Assign(attrs ...field.AssignExpr) IRunAutomationConditionDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r runAutomationConditionDo) Joins(fields ...field.RelationField) IRunAutomationConditionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r runAutomationConditionDo) Preload(fields ...field.RelationField) IRunAutomationConditionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r runAutomationConditionDo) FirstOrInit() (*model.RunAutomationCondition, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.RunAutomationCondition), nil
	}
}

func (r runAutomationConditionDo) FirstOrCreate() (*model.RunAutomationCondition, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.RunAutomationCondition), nil
	}
}

func (r runAutomationConditionDo) FindByPage(offset int, limit int) (result []*model.RunAutomationCondition, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r runAutomationConditionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r runAutomationConditionDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r runAutomationConditionDo) Delete(models ...*model.RunAutomationCondition) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *runAutomationConditionDo) withDO(do gen.Dao) *runAutomationConditionDo {
	r.DO = *do.(*gen.DO)
	return r
}
