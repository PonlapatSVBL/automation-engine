// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"automation-engine/internal/domain/model"
)

func newPolicyConditionOperator(db *gorm.DB, opts ...gen.DOOption) policyConditionOperator {
	_policyConditionOperator := policyConditionOperator{}

	_policyConditionOperator.policyConditionOperatorDo.UseDB(db, opts...)
	_policyConditionOperator.policyConditionOperatorDo.UseModel(&model.PolicyConditionOperator{})

	tableName := _policyConditionOperator.policyConditionOperatorDo.TableName()
	_policyConditionOperator.ALL = field.NewAsterisk(tableName)
	_policyConditionOperator.ConditionID = field.NewString(tableName, "condition_id")
	_policyConditionOperator.OperatorID = field.NewString(tableName, "operator_id")
	_policyConditionOperator.Created = field.NewTime(tableName, "created")
	_policyConditionOperator.CreatedBy = field.NewString(tableName, "created_by")

	_policyConditionOperator.fillFieldMap()

	return _policyConditionOperator
}

type policyConditionOperator struct {
	policyConditionOperatorDo policyConditionOperatorDo

	ALL         field.Asterisk
	ConditionID field.String
	OperatorID  field.String
	Created     field.Time
	CreatedBy   field.String

	fieldMap map[string]field.Expr
}

func (p policyConditionOperator) Table(newTableName string) *policyConditionOperator {
	p.policyConditionOperatorDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p policyConditionOperator) As(alias string) *policyConditionOperator {
	p.policyConditionOperatorDo.DO = *(p.policyConditionOperatorDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *policyConditionOperator) updateTableName(table string) *policyConditionOperator {
	p.ALL = field.NewAsterisk(table)
	p.ConditionID = field.NewString(table, "condition_id")
	p.OperatorID = field.NewString(table, "operator_id")
	p.Created = field.NewTime(table, "created")
	p.CreatedBy = field.NewString(table, "created_by")

	p.fillFieldMap()

	return p
}

func (p *policyConditionOperator) WithContext(ctx context.Context) IPolicyConditionOperatorDo {
	return p.policyConditionOperatorDo.WithContext(ctx)
}

func (p policyConditionOperator) TableName() string { return p.policyConditionOperatorDo.TableName() }

func (p policyConditionOperator) Alias() string { return p.policyConditionOperatorDo.Alias() }

func (p policyConditionOperator) Columns(cols ...field.Expr) gen.Columns {
	return p.policyConditionOperatorDo.Columns(cols...)
}

func (p *policyConditionOperator) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *policyConditionOperator) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 4)
	p.fieldMap["condition_id"] = p.ConditionID
	p.fieldMap["operator_id"] = p.OperatorID
	p.fieldMap["created"] = p.Created
	p.fieldMap["created_by"] = p.CreatedBy
}

func (p policyConditionOperator) clone(db *gorm.DB) policyConditionOperator {
	p.policyConditionOperatorDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p policyConditionOperator) replaceDB(db *gorm.DB) policyConditionOperator {
	p.policyConditionOperatorDo.ReplaceDB(db)
	return p
}

type policyConditionOperatorDo struct{ gen.DO }

type IPolicyConditionOperatorDo interface {
	gen.SubQuery
	Debug() IPolicyConditionOperatorDo
	WithContext(ctx context.Context) IPolicyConditionOperatorDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPolicyConditionOperatorDo
	WriteDB() IPolicyConditionOperatorDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPolicyConditionOperatorDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPolicyConditionOperatorDo
	Not(conds ...gen.Condition) IPolicyConditionOperatorDo
	Or(conds ...gen.Condition) IPolicyConditionOperatorDo
	Select(conds ...field.Expr) IPolicyConditionOperatorDo
	Where(conds ...gen.Condition) IPolicyConditionOperatorDo
	Order(conds ...field.Expr) IPolicyConditionOperatorDo
	Distinct(cols ...field.Expr) IPolicyConditionOperatorDo
	Omit(cols ...field.Expr) IPolicyConditionOperatorDo
	Join(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo
	Group(cols ...field.Expr) IPolicyConditionOperatorDo
	Having(conds ...gen.Condition) IPolicyConditionOperatorDo
	Limit(limit int) IPolicyConditionOperatorDo
	Offset(offset int) IPolicyConditionOperatorDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPolicyConditionOperatorDo
	Unscoped() IPolicyConditionOperatorDo
	Create(values ...*model.PolicyConditionOperator) error
	CreateInBatches(values []*model.PolicyConditionOperator, batchSize int) error
	Save(values ...*model.PolicyConditionOperator) error
	First() (*model.PolicyConditionOperator, error)
	Take() (*model.PolicyConditionOperator, error)
	Last() (*model.PolicyConditionOperator, error)
	Find() ([]*model.PolicyConditionOperator, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PolicyConditionOperator, err error)
	FindInBatches(result *[]*model.PolicyConditionOperator, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PolicyConditionOperator) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPolicyConditionOperatorDo
	Assign(attrs ...field.AssignExpr) IPolicyConditionOperatorDo
	Joins(fields ...field.RelationField) IPolicyConditionOperatorDo
	Preload(fields ...field.RelationField) IPolicyConditionOperatorDo
	FirstOrInit() (*model.PolicyConditionOperator, error)
	FirstOrCreate() (*model.PolicyConditionOperator, error)
	FindByPage(offset int, limit int) (result []*model.PolicyConditionOperator, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPolicyConditionOperatorDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p policyConditionOperatorDo) Debug() IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Debug())
}

func (p policyConditionOperatorDo) WithContext(ctx context.Context) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p policyConditionOperatorDo) ReadDB() IPolicyConditionOperatorDo {
	return p.Clauses(dbresolver.Read)
}

func (p policyConditionOperatorDo) WriteDB() IPolicyConditionOperatorDo {
	return p.Clauses(dbresolver.Write)
}

func (p policyConditionOperatorDo) Session(config *gorm.Session) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Session(config))
}

func (p policyConditionOperatorDo) Clauses(conds ...clause.Expression) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p policyConditionOperatorDo) Returning(value interface{}, columns ...string) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p policyConditionOperatorDo) Not(conds ...gen.Condition) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p policyConditionOperatorDo) Or(conds ...gen.Condition) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p policyConditionOperatorDo) Select(conds ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p policyConditionOperatorDo) Where(conds ...gen.Condition) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p policyConditionOperatorDo) Order(conds ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p policyConditionOperatorDo) Distinct(cols ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p policyConditionOperatorDo) Omit(cols ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p policyConditionOperatorDo) Join(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p policyConditionOperatorDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p policyConditionOperatorDo) RightJoin(table schema.Tabler, on ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p policyConditionOperatorDo) Group(cols ...field.Expr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p policyConditionOperatorDo) Having(conds ...gen.Condition) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p policyConditionOperatorDo) Limit(limit int) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p policyConditionOperatorDo) Offset(offset int) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p policyConditionOperatorDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p policyConditionOperatorDo) Unscoped() IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Unscoped())
}

func (p policyConditionOperatorDo) Create(values ...*model.PolicyConditionOperator) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p policyConditionOperatorDo) CreateInBatches(values []*model.PolicyConditionOperator, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p policyConditionOperatorDo) Save(values ...*model.PolicyConditionOperator) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p policyConditionOperatorDo) First() (*model.PolicyConditionOperator, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PolicyConditionOperator), nil
	}
}

func (p policyConditionOperatorDo) Take() (*model.PolicyConditionOperator, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PolicyConditionOperator), nil
	}
}

func (p policyConditionOperatorDo) Last() (*model.PolicyConditionOperator, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PolicyConditionOperator), nil
	}
}

func (p policyConditionOperatorDo) Find() ([]*model.PolicyConditionOperator, error) {
	result, err := p.DO.Find()
	return result.([]*model.PolicyConditionOperator), err
}

func (p policyConditionOperatorDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PolicyConditionOperator, err error) {
	buf := make([]*model.PolicyConditionOperator, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p policyConditionOperatorDo) FindInBatches(result *[]*model.PolicyConditionOperator, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p policyConditionOperatorDo) Attrs(attrs ...field.AssignExpr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p policyConditionOperatorDo) Assign(attrs ...field.AssignExpr) IPolicyConditionOperatorDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p policyConditionOperatorDo) Joins(fields ...field.RelationField) IPolicyConditionOperatorDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p policyConditionOperatorDo) Preload(fields ...field.RelationField) IPolicyConditionOperatorDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p policyConditionOperatorDo) FirstOrInit() (*model.PolicyConditionOperator, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PolicyConditionOperator), nil
	}
}

func (p policyConditionOperatorDo) FirstOrCreate() (*model.PolicyConditionOperator, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PolicyConditionOperator), nil
	}
}

func (p policyConditionOperatorDo) FindByPage(offset int, limit int) (result []*model.PolicyConditionOperator, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p policyConditionOperatorDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p policyConditionOperatorDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p policyConditionOperatorDo) Delete(models ...*model.PolicyConditionOperator) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *policyConditionOperatorDo) withDO(do gen.Dao) *policyConditionOperatorDo {
	p.DO = *do.(*gen.DO)
	return p
}
